/*
 * sift-r
 * v1.4.0
 * https://github.com/shuckster/sift-r
 * License: MIT
 */
var N=Object.defineProperty,k=Object.defineProperties;var q=Object.getOwnPropertyDescriptors;var j=Object.getOwnPropertySymbols;var z=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable;var w=(t,s,n)=>s in t?N(t,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[s]=n,h=(t,s)=>{for(var n in s||(s={}))z.call(s,n)&&w(t,n,s[n]);if(j)for(var n of j(s))C.call(s,n)&&w(t,n,s[n]);return t},l=(t,s)=>k(t,q(s));import*as d from"match-iz";const{match:A,against:g,when:r,otherwise:c}=d,{not:O,allOf:f,firstOf:m,every:v,gte:D}=d,{isArray:i,isPojo:u,isFunction:E,isString:H}=d,p=t=>s=>t.push(s),B=t=>s=>t.add(s),T=(t,s)=>n=>t.set(s,n),I=t=>([s,n])=>Object.assign(t,{[s]:n}),P=t=>t instanceof Set,S=t=>t instanceof Map,J=t=>t!=null&&[t[Symbol.iterator],t.next].every(E),x=f(i,v(i),v({length:2})),Q=f(u,t=>x(Object.values(t))),M={length:D(2)},R=f(m(i,O(i)),M),F=f(O(P),O(S)),U=f(m(P,F),M),W=f(m(S,F),M),X=f(m(J),M),G=([t,s])=>t.reduce(([n,e],o,a)=>A(o)(r(s[a])(y=>[[...n,y],e]),c(()=>[n,[...e,o]])),[[],[]]),Y=([t])=>G(t.reduce(([s,n],[e,o])=>[[...s,o],[...n,e]],[[],[]])),Z=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>[]),e=[];return t.forEach(g(...s.map((o,a)=>r(o)(p(n[a]))),c(p(e)))),[...n,e]},_=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>new Set),e=new Set;return t.forEach(g(...s.map((o,a)=>r(o)(B(n[a]))),c(B(e)))),[...n,e]},$=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>new Map),e=new Map;return t.forEach((o,a)=>A(o)(...s.map((y,L)=>r(y)(T(n[L],a))),c(T(e,a)))),[...n,e]},K=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>[]),e=[];for(const o of t)A(o)(...s.map((a,y)=>r(a)(p(n[y]))),c(p(e)));return[...n,e]},b=([t,s])=>Object.entries(t).reduce(([n,e],[o,a])=>A(a)(r(s[o])(()=>[l(h({},n),{[o]:a}),e]),c(()=>[n,l(h({},e),{[o]:a})])),[{},{}]),V=([t])=>b(Object.entries(t).reduce(([s,n],[e,[o,a]])=>[l(h({},s),{[e]:a}),l(h({},n),{[e]:o})],[{},{}])),tt=([t,s])=>b([t,Object.keys(t).reduce((n,e)=>l(h({},n),{[e]:s}),{})]),st=([t,s])=>{const n=Array.from({length:s.length}).map(()=>({})),e={};return Object.entries(t).forEach(g(...s.map((o,a)=>r([H,o])(I(n[a]))),c(I(e)))),[...n,e]},nt=g(r([Q])(V),r([u,u])(b),r([u,E])(tt),r([u,i])(st),r([x])(Y),r([i,i])(G),r(R)(Z),r(U)(_),r(W)($),r(X)(K),r([u])(([t])=>[{},t]),r([i])(([t])=>[[],t]),r([P])(([t])=>[new Set([]),t]),r([S])(([t])=>[new Map([]),t]),c(([t])=>[void 0,t]));function rt(t,...s){return nt([t,...s])}const ot=t=>g(r(t,s=>s),c(void 0));export{ot as byPattern,rt as sift};
