/*
 * sift-r
 * v1.4.0
 * https://github.com/shuckster/sift-r
 * License: MIT
 */
var z=Object.create;var g=Object.defineProperty,C=Object.defineProperties,D=Object.getOwnPropertyDescriptor,H=Object.getOwnPropertyDescriptors,J=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols,Q=Object.getPrototypeOf,E=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var v=(t,s,n)=>s in t?g(t,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[s]=n,h=(t,s)=>{for(var n in s||(s={}))E.call(s,n)&&v(t,n,s[n]);if(w)for(var n of w(s))R.call(s,n)&&v(t,n,s[n]);return t},l=(t,s)=>C(t,H(s));var U=(t,s)=>{for(var n in s)g(t,n,{get:s[n],enumerable:!0})},B=(t,s,n,e)=>{if(s&&typeof s=="object"||typeof s=="function")for(let r of J(s))!E.call(t,r)&&r!==n&&g(t,r,{get:()=>s[r],enumerable:!(e=D(s,r))||e.enumerable});return t};var W=(t,s,n)=>(n=t!=null?z(Q(t)):{},B(s||!t||!t.__esModule?g(n,"default",{value:t,enumerable:!0}):n,t)),X=t=>B(g({},"__esModule",{value:!0}),t);var yt={};U(yt,{byPattern:()=>ut,sift:()=>lt});module.exports=X(yt);var O=W(require("match-iz"),1);const{match:m,against:A,when:o,otherwise:c}=O,{not:P,allOf:f,firstOf:p,every:T,gte:Y}=O,{isArray:i,isPojo:u,isFunction:I,isString:Z}=O,M=t=>s=>t.push(s),x=t=>s=>t.add(s),F=(t,s)=>n=>t.set(s,n),G=t=>([s,n])=>Object.assign(t,{[s]:n}),S=t=>t instanceof Set,b=t=>t instanceof Map,_=t=>t!=null&&[t[Symbol.iterator],t.next].every(I),L=f(i,T(i),T({length:2})),$=f(u,t=>L(Object.values(t))),d={length:Y(2)},K=f(p(i,P(i)),d),N=f(P(S),P(b)),V=f(p(S,N),d),tt=f(p(b,N),d),st=f(p(_),d),k=([t,s])=>t.reduce(([n,e],r,a)=>m(r)(o(s[a])(y=>[[...n,y],e]),c(()=>[n,[...e,r]])),[[],[]]),nt=([t])=>k(t.reduce(([s,n],[e,r])=>[[...s,r],[...n,e]],[[],[]])),et=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>[]),e=[];return t.forEach(A(...s.map((r,a)=>o(r)(M(n[a]))),c(M(e)))),[...n,e]},rt=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>new Set),e=new Set;return t.forEach(A(...s.map((r,a)=>o(r)(x(n[a]))),c(x(e)))),[...n,e]},ot=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>new Map),e=new Map;return t.forEach((r,a)=>m(r)(...s.map((y,q)=>o(y)(F(n[q],a))),c(F(e,a)))),[...n,e]},at=([t,...s])=>{const n=Array.from({length:s.length}).map(()=>[]),e=[];for(const r of t)m(r)(...s.map((a,y)=>o(a)(M(n[y]))),c(M(e)));return[...n,e]},j=([t,s])=>Object.entries(t).reduce(([n,e],[r,a])=>m(a)(o(s[r])(()=>[l(h({},n),{[r]:a}),e]),c(()=>[n,l(h({},e),{[r]:a})])),[{},{}]),ct=([t])=>j(Object.entries(t).reduce(([s,n],[e,[r,a]])=>[l(h({},s),{[e]:a}),l(h({},n),{[e]:r})],[{},{}])),it=([t,s])=>j([t,Object.keys(t).reduce((n,e)=>l(h({},n),{[e]:s}),{})]),ft=([t,s])=>{const n=Array.from({length:s.length}).map(()=>({})),e={};return Object.entries(t).forEach(A(...s.map((r,a)=>o([Z,r])(G(n[a]))),c(G(e)))),[...n,e]},ht=A(o([$])(ct),o([u,u])(j),o([u,I])(it),o([u,i])(ft),o([L])(nt),o([i,i])(k),o(K)(et),o(V)(rt),o(tt)(ot),o(st)(at),o([u])(([t])=>[{},t]),o([i])(([t])=>[[],t]),o([S])(([t])=>[new Set([]),t]),o([b])(([t])=>[new Map([]),t]),c(([t])=>[void 0,t]));function lt(t,...s){return ht([t,...s])}const ut=t=>A(o(t,s=>s),c(void 0));0&&(module.exports={byPattern,sift});
